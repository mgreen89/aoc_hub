{"version":3,"sources":["../node_modules/entrance-ws/index.js","main.js"],"names":["ws_url","ws","errorRecv","ws_up","channels","isup_ports","seq_num","wanted_seq_num","reserved_name","RegExp","handleWebsocket","url","app","ports","console","log","injectSend","injectRecv","subscribe","err","send","port_name","length","test","port","channel","camel_to_snake","endsWith","msg","id","JSON","stringify","push","retry_connection","name","slice","split","join","toLowerCase","init_ws","onmessage","nfn","data","parse","undefined","error","value","wanted","onopen","set_ws_state","onclose","reason","setTimeout","state","WebSocket","readyState","close","dev_mode","ws_proto","location","protocol","url_port","hostname","pathname","Elm","Main","init","node","document","querySelector"],"mappings":"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","file":"main.1f19ae8e.js","sourceRoot":"../src","sourcesContent":["'use strict';\n\n// Handle all the EnTrance websocket stuff, now that Elm 0.19\n// has removed the standard WebSocket package. We make this\n// replacement channel-aware, to reduce the Elm boilerplate\n// previously required in complex apps.\n\n\n// Hmmm, mutable global state. Lovely!\nvar ws_url;\nvar ws;\nvar ws_up = false;\nvar channels = {};\nvar isup_ports = [];\nvar errorRecv;\nvar seq_num = 1;\nvar wanted_seq_num = {};\n\n// Reserved port names\nconst reserved_name = new RegExp(\n    '^(errorRecv|injectRecv|injectSend)$'\n);\n\n//\n// Set up everything so the Elm app can use the websocket in the right way\n//\nexport function handleWebsocket(url, app) {\n    ws_url = url;\n\n    // How to send global errors to the app\n    errorRecv = app.ports.errorRecv;\n    if (!errorRecv) {\n        console.log('errorRecv not subscribed to - please fix that!');\n    }\n\n    // Provide a handy means to loop back messages\n    if (app.ports.injectSend && app.ports.injectRecv) {\n        app.ports.injectSend.subscribe(err =>\n            app.ports.injectRecv.send(err));\n    }\n\n    // Create any channels that the app uses\n    for (const port_name in app.ports) {\n        if (port_name.length < 5 || reserved_name.test(port_name)) {\n            continue;\n        }\n        const port = app.ports[port_name];\n        const channel = camel_to_snake(port_name);\n\n        if (port_name.endsWith('Send')) {\n            // How the app sends a message\n            port.subscribe(msg => {\n                msg.channel = channel;\n                if (msg.id == -1) {\n                    msg.id = seq_num++;\n                    wanted_seq_num[channel] = msg.id;\n                }\n                ws.send(JSON.stringify(msg));\n            });\n        } else if (port_name.endsWith('Recv')) {\n            // How the app subscribes to notifications\n            channels[channel] = port;\n        } else if (port_name.endsWith('IsUp')) {\n            // How the app subscribes to up/down state\n            isup_ports.push(port);\n            if (ws_up) {\n                port.send(true);\n            }\n        }\n    }\n\n    // Kick off the first websocket connection\n    retry_connection();\n}\n\n// fooBarBazSend -> foo_bar_baz\nfunction camel_to_snake(name) {\n    return name.slice(0, -4)\n        .split(/(?=[A-Z])/)\n        .join('_')\n        .toLowerCase();\n}\n\n//\n// Handle a new WebSocket (including creating it)\n//\nfunction init_ws() {\n    // Handle incoming websocket notifications\n    ws.onmessage = nfn => {\n        const data = JSON.parse(nfn.data);\n        const channel = data.channel;\n        if (channel === undefined) {\n            // The notification doesn't specify a channel - bad server!\n            error(`Dropping notification without any channel: ${JSON.stringify(nfn)}`);\n            console.log(nfn, nfn.data);\n        } else if (channel == 'error') {\n            // Fast-track the error string to the special error subscription.\n            console.log('Raising error', data);\n            errorRecv.send(data.value);\n        } else {\n            const port = channels[channel];\n            if (port === undefined) {\n                // Nobody is listening on this channel. Life can be harsh.\n                error(`Dropping notification for unused channel ${channel}`);\n                console.log(nfn, channels, data);\n            } else {\n                // Do any sequence number processing\n                const wanted = wanted_seq_num[channel];\n                if (wanted) {\n                    if (data.id == wanted) {\n                        // Match!\n                        delete wanted_seq_num[channel];\n                        port.send(data);\n                    } else {\n                        // Fail! Just log to console\n                        console.log(`Dropping message for channel ${channel} since ` +\n                            `wanted sequence numer ${wanted} but found ${data.id}`,\n                            data);\n                    }\n                } else {\n                    // No sequence number processing required\n                    port.send(data);\n                }\n            }\n        }\n    };\n\n    // Yay! We're up.\n    ws.onopen = () => set_ws_state(true);\n\n    // Boo! We're down.\n    ws.onclose = reason => {\n        // console.log('Websocket closed', reason);\n        if (ws_up) {\n            set_ws_state(false);\n            // In Firefox (but not Chrome or Safari), the websocket close event\n            // can arrive so quickly that, for example, a browser refresh causes\n            // two websocket connection requests (one as a dying gasp from the\n            // old code, then another from the new code). This seems to happen\n            // within a window of 10ms or so. So for Firefox's benefit, wait for\n            // 100ms before reconnecting.\n            setTimeout(() => {\n                console.log('Reconnecting to websocket');\n                retry_connection();\n            }, 100);\n        }\n    };\n\n    // This is always boring\n    // ws.onerror = err => console.log('WebSocket error', err);\n}\n\n// Update our notion of the websocket's state\nfunction set_ws_state(state) {\n    //console.log(`WebsocketIsUp is ${state}`, isup_ports);\n    ws_up = state;\n    for (const port of isup_ports) {\n        port.send(state);\n    }\n}\n\n// Try to connect to the server.\n// Exponential backoff shouldn't be a win for the EnTrance\n// use cases, so simply always try reconnecting after two seconds.\nfunction retry_connection() {\n    ws = new WebSocket(ws_url);\n    init_ws();\n    setTimeout(() => {\n        if (ws.readyState != 1) {\n            ws.close();\n            retry_connection();\n        }\n    }, 2000);\n}\n\n// Raise an error - should only really be during development, when the\n// developer has done something wrong.\nfunction error(msg) {\n    console.log(msg);\n    errorRecv.send(msg);\n}\n","'use strict';\n\n// Compute the URL of the websocket\nconst dev_mode = process.env.NODE_ENV !== 'production';\nconst ws_proto = location.protocol === 'https:' ? 'wss:' : 'ws:';\nconst url_port = dev_mode ? \":8000\" : (location.port ? `:${location.port}` : '');\nconst ws_url = `${ws_proto}//${location.hostname}${url_port}${location.pathname}ws`;\n\n// Initialise the Elm app\nimport { Elm } from './Main.elm';\nconst app = Elm.Main.init({node: document.querySelector('main')});\n\n// Do the websocket stuff\nimport { handleWebsocket } from 'entrance-ws';\nhandleWebsocket(ws_url, app);\n"]}